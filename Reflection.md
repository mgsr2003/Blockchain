Working on this mini-blockchain gave me a concrete, hands-on understanding of hashing, immutability, and Proof-of-Work (PoW). I observed that a block’s hash is derived not only from its own contents but also from the previous block’s hash. Because each block references its predecessor’s fingerprint, any small change — for example modifying a transaction amount — changes that block’s hash and breaks the linkage, causing all subsequent blocks to fail validation. This chaining is the core mechanism that enforces immutability in blockchains.
Implementing PoW clarified how computational cost underpins blockchain security. Requiring hashes that begin with a set number of leading zeros forces miners to try many nonces before finding a valid hash. As I increased the difficulty from 3 to 5, mining runtimes and nonce values rose dramatically, demonstrating how PoW raises the economic and computational barrier for an attacker. To successfully conceal tampering, an adversary would need to re-mine the altered block and every following block faster than the honest network — a task that quickly becomes infeasible as difficulty grows.
What surprised me most was how rapidly the system becomes resource intensive. Even with only a handful of blocks, setting the difficulty to 5 put noticeable load on my CPU, which illustrated why production networks require specialized hardware and why consensus rules (like PoW) are essential. I also learned the importance of consistent data serialization: tiny differences in how transactions are represented change hashes, so canonical serialization is critical for consensus. Overall, this project transformed abstract concepts into tangible behavior: hashing produces verifiable fingerprints, block linkage enforces immutability, and PoW converts security into measurable computational cost.
